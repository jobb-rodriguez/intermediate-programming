# Problem Solving Process

# Why follow a process?
1. **Clarity of Problem Understanding:** Following a process ensures a clear understanding of the problem, enabling precise definition and identification of requirements.
2. **Systematic Approach:** It promotes a systematic step-by-step methodology, aiding in the organization of thoughts and preventing oversight of critical aspects during solution development.
3. **Error Identification and Correction:** A structured process facilitates the identification of errors, leading to efficient debugging and refining of solutions, contributing to the overall quality of the program.

# For Programming Problems
## The process
1. Read the problem
2. What is asked?
3. What is the input format?
4. What is the expected output format?
5. What are the problem's constraints?
6. Which data structure and algorithm can we use?
7. Write the algorithm's pseudocode. *You may use a flowchart as well.*
8. Program.
9. Check program based on sample inputs.
10. Debug and return to #1 as needed.
11. Submit your work.

> [!NOTE]
> For advanced practitioners, consider the Big-O of the the solution. You can start with the naive approach before proceeding to the best approach.

## Sample Problem: FizzBuzz
Write a short program that prints each number from 1 to 100 on a new line. 

For each multiple of 3, print ```"Fizz"``` instead of the number. 

For each multiple of 5, print ```"Buzz"``` instead of the number. 

For numbers which are multiples of both 3 and 5, print ```"FizzBuzz"``` instead of the number.

# Problem Solving Process in Practice
The foundations you built for programming problems will allow you to program and debug in practice efficiently and effectively.

## Programming a Feature
1. What is the expected result?
2. What are the subfeatures (if applicable)? *This will allow you to break the big feature into atomic achievable tasks*.
3. What are the approaches for programming the feature?
4. Pick a solution that best match your needs.
5. Write the algorithm's pseudocode based on your selection in (4).
6. Program.
7. Check if your updated program meets the expected result.
8. Debug and return to #1 as needed.
9. Close the task. Commit and push your changes depending on your organization's git practice.

## Debugging in Practice
1. Understand how the bug occurred.
  - What are the steps you took for the bug to occur?
  - Can you reproduce the bug?
  - What is the result?
  - Why did the bug happen?
2. What is the expected result?
3. Based on (1) and (2), what are our solutions?
4. Pick a solution that best match your needs.
5. Write the algorithm's pseudocode based on your selection in (4).
6. Program.
7. Check if your updated program meets the expected result.
8. Debug and return to #1 as needed.
9. Close the bug issue. Commit and push your changes depending on your organization's git practice.